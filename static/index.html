<!-- static/index.html -->
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>WebRTC Echo Test</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 600px;
                margin: 50px auto;
                padding: 20px;
                background: #f5f5f5;
            }
            .container {
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            button {
                background: #4CAF50;
                color: white;
                padding: 15px 30px;
                border: none;
                border-radius: 5px;
                font-size: 16px;
                cursor: pointer;
                margin: 10px 5px;
            }
            button:hover { background: #45a049; }
            button:disabled { 
                background: #cccccc;
                cursor: not-allowed;
            }
            .status {
                margin: 20px 0;
                padding: 15px;
                border-radius: 5px;
                font-weight: bold;
            }
            .status.connecting { background: #fff3cd; color: #856404; }
            .status.connected { background: #d4edda; color: #155724; }
            .status.error { background: #f8d7da; color: #721c24; }
            .timing {
                background: #e7f3ff;
                padding: 15px;
                border-radius: 5px;
                margin: 10px 0;
            }
        </style>
    </head>
<body>
    <div class="container">
        <h1>ğŸ¤ WebRTC Echo í…ŒìŠ¤íŠ¸</h1>
        <p>ë§ˆì´í¬ë¥¼ í†µí•´ ë§í•˜ë©´ echoë¡œ ë“¤ë ¤ì˜µë‹ˆë‹¤</p>
        
        <button id="start">ì—°ê²° ì‹œì‘</button>
        <button id="stop" disabled>ì—°ê²° ì¢…ë£Œ</button>
        
        <div id="status" class="status" style="display: none;"></div>
        <div id="timing" class="timing" style="display: none;"></div>
        
        <div id="connectionInfo" style="margin-top: 20px; display: none;">
            <h3>ì—°ê²° ì •ë³´</h3>
            <p id="connectionState">ìƒíƒœ: -</p>
            <p id="iceState">ICE ìƒíƒœ: -</p>
        </div>
    </div>

    <script>
        let pc = null;
        let localStream;
        let startTime;
        let connectTime;

        const statusEl = document.getElementById('status');
        const timingEl = document.getElementById('timing');
        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const connectionInfoEl = document.getElementById('connectionInfo');
        const connectionStateEl = document.getElementById('connectionState');
        const iceStateEl = document.getElementById('iceState');

        function showStatus(message, type = 'connecting') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        function showTiming(message) {
            timingEl.innerHTML = message;
            timingEl.style.display = 'block';
        }

        function updateConnectionInfo() {
            if (pc) {
                connectionStateEl.textContent = `ìƒíƒœ: ${pc.connectionState}`;
                iceStateEl.textContent = `ICE ìƒíƒœ: ${pc.iceConnectionState}`;
                connectionInfoEl.style.display = 'block';
            }
        }

        async function createPeerConnection() {
            try {
                showStatus('ğŸ”— ì„œë²„ì—ì„œ ICE ì„œë²„ ì •ë³´ ê°€ì ¸ì˜¤ëŠ” ì¤‘...', 'connecting');
                
                // ì„œë²„ì—ì„œ í†µì¼ëœ ICE ì„œë²„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (ì§ì ‘ í•˜ë“œì½”ë”© ê¸ˆì§€)
                const response = await fetch('/ice-servers');
                if (!response.ok) {
                    throw new Error(`ICE ì„œë²„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('âœ… ì„œë²„ì—ì„œ ë°›ì€ ICE ì„œë²„:', data.iceServers);
                console.log('ğŸ“Š ìºì‹œ ì •ë³´:', data.cacheInfo);
                
                // ICE ì„œë²„ íƒ€ì… í™•ì¸
                const hasTwilioTurn = data.iceServers.some(server => 
                    server.urls && server.urls.includes && 
                    (server.urls.includes('twilio.com') || server.urls.includes('global.turn'))
                );
                const hasCustomTurn = data.iceServers.some(server => 
                    server.urls && server.urls.includes('turn:') && 
                    !server.urls.includes('twilio.com')
                );
                
                if (hasTwilioTurn) {
                    console.log('ğŸ¯ Twilio TURN ì„œë²„ ê°ì§€ë¨!');
                } else if (hasCustomTurn) {
                    console.log('ğŸ”§ Custom TURN ì„œë²„ ê°ì§€ë¨');
                } else {
                    console.log('âš ï¸ STUN ì„œë²„ë§Œ ì‚¬ìš© ì¤‘');
                }
                
                if (data.error) {
                    console.warn('âš ï¸ ì„œë²„ ê²½ê³ :', data.error);
                }
                
                // RTCPeerConnection ìƒì„± (ì„œë²„ì™€ ë™ì¼í•œ ICE ì„œë²„ ì‚¬ìš©)
                pc = new RTCPeerConnection({
                    iceServers: data.iceServers,
                    iceCandidatePoolSize: 10,
                    iceTransportPolicy: 'all',  // ëª¨ë“  ì—°ê²° ë°©ì‹ í—ˆìš©
                    bundlePolicy: 'max-bundle',
                    rtcpMuxPolicy: 'require'
                });
                
                setupPeerConnectionEvents();
                
                showStatus('âœ… PeerConnection ìƒì„± ì™„ë£Œ', 'connecting');
                return pc;
                
            } catch (error) {
                console.error('âŒ PeerConnection ìƒì„± ì‹¤íŒ¨:', error);
                throw new Error(`PeerConnection ìƒì„± ì‹¤íŒ¨: ${error.message}`);
            }
        }

        function setupPeerConnectionEvents() {
            if (!pc) {
                console.error('PeerConnectionì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }
            
            // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
            pc.onconnectionstatechange = () => {
                console.log('Connection state:', pc.connectionState);
                updateConnectionInfo();
                
                if (pc.connectionState === 'connected' && !connectTime) {
                    connectTime = Date.now();
                    const totalTime = connectTime - startTime;
                    showStatus(`âœ… ì—°ê²° ì™„ë£Œ! (${totalTime}ms)`, 'connected');
                    showTiming(`
                        <strong>ì—°ê²° ì‹œê°„ ë¶„ì„:</strong><br>
                        â€¢ ì „ì²´ ì—°ê²° ì‹œê°„: <strong>${totalTime}ms</strong><br>
                        â€¢ ëª©í‘œ: 1-2ì´ˆ (1000-2000ms)<br>
                        â€¢ ìƒíƒœ: ${totalTime < 2000 ? 'âœ… ëª©í‘œ ë‹¬ì„±' : 'âŒ ê°œì„  í•„ìš”'}
                    `);
                } else if (pc.connectionState === 'failed') {
                    showStatus('âŒ ì—°ê²° ì‹¤íŒ¨', 'error');
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', pc.iceConnectionState);
                updateConnectionInfo();
                
                if (pc.iceConnectionState === 'failed') {
                    console.error('âŒ ICE ì—°ê²° ì™„ì „ ì‹¤íŒ¨!');
                    
                    // ICE ì¬ì‹œì‘ ì‹œë„
                    console.log('ğŸ”„ ICE ì¬ì‹œì‘ ì‹œë„...');
                    showStatus('ğŸ”„ ICE ì¬ì‹œì‘ ì¤‘...', 'connecting');
                    
                    try {
                        pc.restartIce();
                        setTimeout(() => {
                            if (pc.iceConnectionState === 'failed') {
                                console.error('âŒ ICE ì¬ì‹œì‘ë„ ì‹¤íŒ¨');
                                showStatus('âŒ ëª¨ë“  TURN ì„œë²„ ì—°ê²° ì‹¤íŒ¨', 'error');
                                startBtn.disabled = false;
                                stopBtn.disabled = true;
                            }
                        }, 5000);
                    } catch (e) {
                        console.error('ICE ì¬ì‹œì‘ ì˜¤ë¥˜:', e);
                        showStatus('âŒ ICE ì¬ì‹œì‘ ì‹¤íŒ¨', 'error');
                        startBtn.disabled = false;
                        stopBtn.disabled = true;
                    }
                } else if (pc.iceConnectionState === 'disconnected') {
                    console.warn('âš ï¸ ICE ì—°ê²° ëŠê¹€ - ìë™ ì¬ì—°ê²° ëŒ€ê¸°');
                    showStatus('ğŸ”„ ì—°ê²° ëŠê¹€, ì¬ì—°ê²° ì‹œë„ ì¤‘...', 'connecting');
                } else if (pc.iceConnectionState === 'checking') {
                    showStatus('ğŸ” TURN ì„œë²„ ì—°ê²° í™•ì¸ ì¤‘...', 'connecting');
                } else if (pc.iceConnectionState === 'connected') {
                    console.log('âœ… ICE ì—°ê²° ì„±ê³µ!');
                }
            };

            // ICE candidate ìˆ˜ì§‘ ë””ë²„ê¹…
            pc.onicecandidateerror = (event) => {
                console.error('ICE candidate error:', event);
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const candidate = event.candidate.candidate;
                    // candidate íƒ€ì… êµ¬ë¶„ì„ ë” ëª…í™•í•˜ê²Œ í‘œì‹œ
                    let type = '-';
                    let serverType = '';
                    
                    if (candidate.includes('typ relay')) {
                        type = 'TURN relay';
                        // Twilio TURN ì„œë²„ ê°ì§€
                        if (candidate.includes('global.turn.twilio.com') || candidate.includes('turn.twilio.com')) {
                            serverType = ' (Twilio)';
                        } else {
                            serverType = ' (Custom)';
                        }
                    } else if (candidate.includes('typ srflx')) {
                        type = 'STUN srflx';
                        if (candidate.includes('stun.l.google.com')) {
                            serverType = ' (Google)';
                        }
                    } else if (candidate.includes('typ host')) {
                        type = 'Host';
                    }
                    
                    console.log(`[ICE] ${type}${serverType} candidate:`, candidate);
                } else {
                    console.log('ICE gathering complete');
                }
            };

            pc.ontrack = (event) => {
                console.log('Received track:', event.track.kind);
                const remoteStream = event.streams[0];
                const audio = new Audio();
                audio.srcObject = remoteStream;
                audio.autoplay = true;
                audio.volume = 1.0;
                document.body.appendChild(audio);
                
                showStatus('ğŸµ ìŒì„± ìŠ¤íŠ¸ë¦¼ ì—°ê²°ë¨! ë§í•´ë³´ì„¸ìš”!', 'connected');
            };
        }

        async function start() {
            try {
                // ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
                if (pc && (pc.connectionState === 'connecting' || pc.connectionState === 'connected')) {
                    showStatus('âš ï¸ ì´ë¯¸ ì—°ê²° ì¤‘ì…ë‹ˆë‹¤', 'connecting');
                    return;
                }

                startTime = Date.now();
                connectTime = null;
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                // PeerConnection ìƒì„± (í•­ìƒ ìƒˆë¡œ ìƒì„±)
                await createPeerConnection();
                
                showStatus('ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì¤‘...');
                
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                localStream.getTracks().forEach(track => {
                    console.log('Adding track:', track.kind);
                    pc.addTrack(track, localStream);
                });

                showStatus('ğŸ“¡ WebRTC ì—°ê²° ì„¤ì • ì¤‘...');
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                showStatus('ğŸŒ ì„œë²„ì™€ í†µì‹  ì¤‘...');
                
                const response = await fetch('/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pc.localDescription)
                });

                if (!response.ok) {
                    throw new Error(`ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
                }

                const answer = await response.json();
                console.log('Received answer from server');
                
                await pc.setRemoteDescription(new RTCSessionDescription(answer));

                showStatus('ğŸ”„ ì—°ê²° ì¤‘... ICE candidate êµí™˜ ì¤‘');

            } catch (error) {
                console.error('Connection error:', error);
                showStatus(`âŒ ì˜¤ë¥˜: ${error.message}`, 'error');
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        async function stop() {
            console.log('Stopping connection...');
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    console.log('Stopping track:', track.kind);
                    track.stop();
                });
                localStream = null;
            }
            
            if (pc) {
                pc.close();
                pc = null;
            }
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            statusEl.style.display = 'none';
            timingEl.style.display = 'none';
            connectionInfoEl.style.display = 'none';
            
            showStatus('ğŸ”Œ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
            
            // ê¸°ì¡´ audio ì—˜ë¦¬ë¨¼íŠ¸ë“¤ ì œê±°
            document.querySelectorAll('audio').forEach(audio => audio.remove());
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
        startBtn.onclick = start;
        stopBtn.onclick = stop;

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì„œë²„ ìƒíƒœ í™•ì¸
        window.addEventListener('load', async () => {
            try {
                const response = await fetch('/health');
                const health = await response.json();
                console.log('âœ… ì„œë²„ ìƒíƒœ:', health);
            } catch (error) {
                console.warn('ì„œë²„ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨:', error);
            }
        });
    </script>
</body>
</html>
