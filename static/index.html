<!-- static/index.html -->
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>WebRTC Echo Test</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 600px;
                margin: 50px auto;
                padding: 20px;
                background: #f5f5f5;
            }
            .container {
                background: white;
                padding: 30px;
                border-radius: 10px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            }
            button {
                background: #4CAF50;
                color: white;
                padding: 15px 30px;
                border: none;
                border-radius: 5px;
                font-size: 16px;
                cursor: pointer;
                margin: 10px 5px;
            }
            button:hover { background: #45a049; }
            button:disabled { 
                background: #cccccc;
                cursor: not-allowed;
            }
            .status {
                margin: 20px 0;
                padding: 15px;
                border-radius: 5px;
                font-weight: bold;
            }
            .status.connecting { background: #fff3cd; color: #856404; }
            .status.connected { background: #d4edda; color: #155724; }
            .status.error { background: #f8d7da; color: #721c24; }
            .timing {
                background: #e7f3ff;
                padding: 15px;
                border-radius: 5px;
                margin: 10px 0;
            }
        </style>
    </head>
<body>
    <div class="container">
        <h1>ğŸ¤ WebRTC Echo í…ŒìŠ¤íŠ¸</h1>
        <p>ë§ˆì´í¬ë¥¼ í†µí•´ ë§í•˜ë©´ echoë¡œ ë“¤ë ¤ì˜µë‹ˆë‹¤</p>
        
        <button id="start">ì—°ê²° ì‹œì‘</button>
        <button id="stop" disabled>ì—°ê²° ì¢…ë£Œ</button>
        
        <div id="status" class="status" style="display: none;"></div>
        <div id="timing" class="timing" style="display: none;"></div>
        
        <div id="connectionInfo" style="margin-top: 20px; display: none;">
            <h3>ì—°ê²° ì •ë³´</h3>
            <p id="connectionState">ìƒíƒœ: -</p>
            <p id="iceState">ICE ìƒíƒœ: -</p>
        </div>
    </div>

    <script>
        let pc = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { urls: "stun:stun.cloudflare.com:3478" }
            ],
            iceCandidatePoolSize: 10
        });

        let localStream;
        let startTime;
        let connectTime;

        const statusEl = document.getElementById('status');
        const timingEl = document.getElementById('timing');
        const startBtn = document.getElementById('start');
        const stopBtn = document.getElementById('stop');
        const connectionInfoEl = document.getElementById('connectionInfo');
        const connectionStateEl = document.getElementById('connectionState');
        const iceStateEl = document.getElementById('iceState');

        function showStatus(message, type = 'connecting') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
        }

        function showTiming(message) {
            timingEl.innerHTML = message;
            timingEl.style.display = 'block';
        }

        function updateConnectionInfo() {
            connectionStateEl.textContent = `ìƒíƒœ: ${pc.connectionState}`;
            iceStateEl.textContent = `ICE ìƒíƒœ: ${pc.iceConnectionState}`;
            connectionInfoEl.style.display = 'block';
        }

        function setupPeerConnectionEvents() {
            // ì—°ê²° ìƒíƒœ ëª¨ë‹ˆí„°ë§
            pc.onconnectionstatechange = () => {
                console.log('Connection state:', pc.connectionState);
                updateConnectionInfo();
                
                if (pc.connectionState === 'connected' && !connectTime) {
                    connectTime = Date.now();
                    const totalTime = connectTime - startTime;
                    showStatus(`âœ… ì—°ê²° ì™„ë£Œ! (${totalTime}ms)`, 'connected');
                    showTiming(`
                        <strong>ì—°ê²° ì‹œê°„ ë¶„ì„:</strong><br>
                        â€¢ ì „ì²´ ì—°ê²° ì‹œê°„: <strong>${totalTime}ms</strong><br>
                        â€¢ ëª©í‘œ: 1-2ì´ˆ (1000-2000ms)<br>
                        â€¢ ìƒíƒœ: ${totalTime < 2000 ? 'âœ… ëª©í‘œ ë‹¬ì„±' : 'âŒ ê°œì„  í•„ìš”'}
                    `);
                } else if (pc.connectionState === 'failed') {
                    showStatus('âŒ ì—°ê²° ì‹¤íŒ¨', 'error');
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log('ICE connection state:', pc.iceConnectionState);
                updateConnectionInfo();
                
                if (pc.iceConnectionState === 'failed') {
                    showStatus('âŒ ICE ì—°ê²° ì‹¤íŒ¨ - NAT/ë°©í™”ë²½ ë¬¸ì œì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤', 'error');
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                }
            };

            // ICE candidate ìˆ˜ì§‘ ë””ë²„ê¹…
            pc.onicecandidateerror = (event) => {
                console.error('ICE candidate error:', event);
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('ICE candidate:', event.candidate.candidate);
                } else {
                    console.log('ICE gathering complete');
                }
            };

            pc.ontrack = (event) => {
                console.log('Received track:', event.track.kind);
                const remoteStream = event.streams[0];
                const audio = new Audio();
                audio.srcObject = remoteStream;
                audio.autoplay = true;
                audio.volume = 1.0;
                document.body.appendChild(audio);
                
                showStatus('ğŸµ ìŒì„± ìŠ¤íŠ¸ë¦¼ ì—°ê²°ë¨! ë§í•´ë³´ì„¸ìš”!', 'connected');
            };
        }

        async function start() {
            try {
                // ì´ë¯¸ ì—°ê²° ì¤‘ì´ë¼ë©´ ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
                if (pc.connectionState === 'connecting' || pc.connectionState === 'connected') {
                    showStatus('âš ï¸ ì´ë¯¸ ì—°ê²° ì¤‘ì…ë‹ˆë‹¤', 'connecting');
                    return;
                }

                startTime = Date.now();
                connectTime = null;
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
                showStatus('ğŸ¤ ë§ˆì´í¬ ê¶Œí•œ ìš”ì²­ ì¤‘...');
                
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });
                
                localStream.getTracks().forEach(track => {
                    console.log('Adding track:', track.kind);
                    pc.addTrack(track, localStream);
                });

                showStatus('ğŸ“¡ WebRTC ì—°ê²° ì„¤ì • ì¤‘...');
                
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                showStatus('ğŸŒ ì„œë²„ì™€ í†µì‹  ì¤‘...');
                
                const response = await fetch('/offer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(pc.localDescription)
                });

                if (!response.ok) {
                    throw new Error(`ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
                }

                const answer = await response.json();
                console.log('Received answer from server');
                
                await pc.setRemoteDescription(new RTCSessionDescription(answer));

                showStatus('ğŸ”„ ì—°ê²° ì¤‘... ICE candidate êµí™˜ ì¤‘');

            } catch (error) {
                console.error('Connection error:', error);
                showStatus(`âŒ ì˜¤ë¥˜: ${error.message}`, 'error');
                startBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        function stop() {
            console.log('Stopping connection...');
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    console.log('Stopping track:', track.kind);
                    track.stop();
                });
                localStream = null;
            }
            
            if (pc) {
                pc.close();
            }
            
            // ìƒˆë¡œìš´ PeerConnection ìƒì„±
            pc = new RTCPeerConnection({
                iceServers: [
                    { urls: "stun:stun.l.google.com:19302" },
                    { urls: "stun:stun1.l.google.com:19302" },
                    { urls: "stun:stun2.l.google.com:19302" },
                    { urls: "stun:stun.cloudflare.com:3478" }
                ],
                iceCandidatePoolSize: 10
            });
            
            // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë‹¤ì‹œ ì„¤ì •
            setupPeerConnectionEvents();
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            
            statusEl.style.display = 'none';
            timingEl.style.display = 'none';
            connectionInfoEl.style.display = 'none';
            
            showStatus('ğŸ”Œ ì—°ê²°ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
            
            // ê¸°ì¡´ audio ì—˜ë¦¬ë¨¼íŠ¸ë“¤ ì œê±°
            document.querySelectorAll('audio').forEach(audio => audio.remove());
        }

        // ì´ˆê¸° ì´ë²¤íŠ¸ ì„¤ì •
        setupPeerConnectionEvents();
        
        startBtn.onclick = start;
        stopBtn.onclick = stop;
    </script>
</body>
</html>
